---
weight: 411
bookCollapseSection: false
title: "4.1.1 容器化发展"
---

# Introduction
 容器可能看起来像是一种突然出现的用于改变 IT 的技术，但实际上它们绝不是新事物。容器的最初想法自 1970 年代就已经存在，当时该概念首次在 Unix 系统上用于更好地隔离应用程序代码。虽然在某些应用程序开发和部署场景中很有用，但容器在早期的最大缺点是一个简单的事实，即它们不是可移植的。

 

容器是如何演变的
早在 1970 年代，早期的容器创建了一个隔离的环境，服务和应用程序可以在其中运行而不会干扰其他进程——产生类似于沙盒的东西来测试应用程序、服务和其他进程。最初的想法是将容器的工作负载与生产系统隔离开来，使开发人员能够在生产硬件上测试他们的应用程序和流程，而不会冒中断其他服务的风险。多年来，容器已经获得了隔离用户、文件、网络等的能力。容器现在也可以拥有自己的 IP 地址。

 

大约在 2012 年，容器的可用性得到了很大的提升，这要归功于众多 Linux 发行版带来了额外的部署选项和管理工具。在 Linux 平台上运行的容器被转变为操作系统级的虚拟化技术，专门设计用于在单个 Linux 主机上提供多个隔离的 Linux 环境。 Linux 容器不需要专用的客户操作系统；相反，它们共享主机操作系统内核。消除对专用操作系统的需求还允许容器比任何虚拟机更快地启动。

 

容器能够使用 Linux 内核特性，如 Namespaces、Apparmor、SELinux 配置文件、chroot 和 CGroups 来创建隔离的操作环境，而 Linux 安全模块增加了一层保护，承诺从容器访问主机和内核防止入侵。容器化的 Linux 风格还通过允许容器从其主机操作系统运行不同的 Linux 发行版来增加更多的灵活性，只要两个操作系统都运行在相同的 CPU 架构上。

 

Linux 容器提供了基于各种 Linux 发行版创建容器映像的方法，同时还包含用于管理容器生命周期的 API。 Linux 发行版还包括用于与 API 交互的必要客户端工具、用于拍摄快照的捆绑功能，以及支持将容器实例从一个容器主机迁移到另一个容器主机。

 

但是，虽然在 Linux 平台上运行的容器增加了它们的适用性，但仍有几个重大挑战需要克服，包括统一管理、真正的可移植性、兼容性和规模控制。

 

清除障碍
随着 Apache Mesos、Google Borg 和 Facebook Tupperware 的到来，Linux 平台上容器的使用开始显着提升，所有这些都带来了不同程度的容器编排和集群管理能力。这些平台提供了按需启动数百个容器的能力，以及对自动故障转移的支持，以及管理容器所需的其他关键任务功能



---------


然而，容器不断发展，带来了现在被广泛应用以使企业 IT 更加灵活的抽象功能。由于 Docker 容器的兴起，现在可以更轻松地在不同版本的 Linux 之间移动工作负载，以及编排容器以创建微服务。

 

就像容器一样，微服务也不是一个新概念。这个概念可以追溯到面向服务的架构 (SOA)。不同的是，基于容器的微服务更细化，更易于管理。不是通过“修补”它们来更新应用程序，而是通过将现有容器替换为包含新功能的容器来将新功能添加到微服务中。然后，每个微服务都会公开一个应用程序编程接口 (API)，使开发人员能够以编程方式将它们组合在一起，以比以往更快的速度构建应用程序。该方法还有助于简化单个组件的持续维护并增强整体应用程序的安全性。

 

显然，构建和维护一系列基于容器的微服务将比维护一个单体应用程序更具挑战性。为了应对这一挑战，出现了各种用于编排在分布式计算环境中运行的容器的平台。

 

只有当 IT 组织开始欣赏这些平台提供的功能时，才会清楚容器如何即将成为新抽象层的基础组件，该抽象层有望永远改变企业 IT 的管理方式。







=========


作为“没关系成为新人”系列的一部分，本周我一直在对容器进行大量研究。我的目标是为任何人（无论技术背景如何）打下基础，让他们能够开始使用和学习容器——无论是 LXC、Docker 还是下一个大型容器技术。

就个人而言，我通过故事学得最好，为了应对新事物，我必须在脑海中发展故事；我不仅想了解我们在学习过程中所处的位置，还想了解我们是如何到达这里的。所以我开始拼凑容器技术的历史，我发现要完全理解它，我们需要回溯到比你想象的更远的地方。我们需要回到 1960 年代早期的虚拟化。

虚拟化的发展

早在 60 年代，计算机还是一种稀有商品。光是租一个，每月就要花费一千多美元，这让许多企业望而却步。从这个角度来看，1960 年的 1,000 美元与 2018 年的 8,385 美元具有相同的购买力。

他们说需求是发明之母，计算机的历史也不例外。最早的计算机通常专门用于可能需要几天甚至几周才能运行的特定任务，这就是为什么在 1960 年代和整个 1970 年代，我们看到了虚拟化的发展。这种发展是由同时在许多用户之间共享计算机资源的需要推动的。

随着集中式计算机的出现，我们开始看到我们现在所说的虚拟化的初步迹象。

在整个 1960 年代，多个计算机终端连接到一个大型机，这使得计算可以在一个中心位置完成。集中式计算机使从一个位置控制所有处理成为可能，因此如果一个终端出现故障，用户只需转到另一个终端，在那里登录，仍然可以访问他们的所有文件。然而，这确实有一些缺点。例如，如果用户要让中央计算机崩溃，系统就会因所有人而崩溃。像这样的问题表明，计算机不仅需要能够分离出个人，还需要能够分离出系统进程。

1979 年，随着 chroot（更改根）命令的开发，我们朝着创建共享但隔离的环境又迈出了一步。 chroot 命令可以更改正在运行的进程及其所有子进程的明显根目录。这使得将系统进程隔离到它们自己的隔离文件系统中成为可能，这样就可以在不影响全局系统环境的情况下进行测试。 1982 年 3 月，Bill Joy 在 Unix 的第 7 版中添加了 chroot 命令。


为了理解容器，我们可以稍微向前跳到 1990 年代，当时计算机安全和网络研究人员 Bill Cheswick 正在努力了解如果允许访问他的系统，破解者将如何利用他们的时间。对于那些不熟悉“破解者”一词的人，它用于指代出于恶意原因闯入计算机系统的人。现在你可能会想，“等等……那不是黑客吗？”但在安全领域，黑客一词通常用于定义识别安全漏洞以便修复而不是利用它们的人。虽然这种差异可能需要它自己的博客文章，但现在，我将使用饼干这个词，因为这是 Cheswick 在他的论文“与 Berferd 的一个晚上，其中一个饼干被引诱、忍受和研究”中使用的术语。在这项研究中，Cheswick 建立了一个环境，使他能够分析破解者的击键，以便追踪破解者并学习他们的技术。他的解决方案是使用 chrooted 环境并对其进行修改。他的研究成果就是我们现在所知的 Linux jail 命令。

2000 年 3 月 4 日，FreeBSD 将 jail 命令引入其操作系统。虽然它类似于 chroot 命令，但它还包括用于隔离文件系统、用户、网络等的附加进程沙盒功能。FreeBSD jail 使我们能够分配 IP 地址、配置自定义软件安装以及对每个 jail 进行修改。这并非没有自己的问题，因为监狱内的应用程序的功能有限。

2004 年，我们看到了 Solaris 容器的发布，它通过使用 Solaris Zones 创建了完整的应用程序环境。使用区域，您可以为应用程序提供完整的用户、进程和文件系统空间，以及对系统硬件的访问权限。但是，该应用程序只能看到它自己区域内的内容。2006 年，Google 的工程师宣布他们推出了用于隔离和限制进程资源使用的进程容器。 2007 年，这些流程容器被重命名为控制组 (cgroups)，以避免与容器一词混淆。

2008 年 cgroups 并入 Linux 内核 2.6.24

在规模上。但直到我们现在称之为 Docker 的容器变体，才真正开始向容器的转变。

 

Docker（技术和公司）一开始是一个名为 dotCloud 的公共 PaaS 产品。 PaaS 解决方案受益于容器技术，它带来了新的功能，例如实时迁移和不间断更新。 2013年，dotCloud开源了其底层容器技术，并称之为Docker Project。对 Docker 项目的日益支持催生了一个庞大的容器采用者社区。不久之后，dotCloud 成为 Docker, Inc.，它除了为 Docker 容器技术做出贡献外，还开始构建自己的管理平台。

 

Docker 的流行催生了多个管理平台，包括 Marathon、Kubernetes、Docker Swarm，以及更广泛地说，Mesosphere 在 Mesos 之上构建的 DC/OS 环境，不仅可以管理容器，还可以管理大量其他遗留应用程序例如，写入的数据服务。爪哇。尽管每个平台在如何最好地提供编排和管理方面都有自己的看法，但它们都有一个共同点——使容器在企业中更加主流的驱动力。

 

但是，要进一步将容器应用到企业中，需要的不仅仅是编排和管理工具。它也需要目的。换句话说，除非他们了解技术可以解决的问题，否则任何人都不应该关注容器化。

 

容器的未来
容器通过仅在主机操作系统和应用程序（或服务）之间创建一个抽象层来避开大部分包袱。与在虚拟机上部署容器相比，这种方法允许每台物理机运行更多的容器。

 

从架构的角度来看，虚拟化用于抽象硬件，这意味着每个虚拟机都必须具有操作系统及其所有依赖项——只有这样才能安装应用程序或服务并使其可用于云实例。

 

容器也比虚拟机小得多。由于这些问题，预计更多的容器将部署在裸机服务器上。展望未来，已经表明容器将部署在更轻量级的管理程序上以提供更大的隔离，而不必产生与部署在现有管理程序上的虚拟机相关的所有开销。

 

然而，今天，大多数容器都部署在本地或公共云中运行的虚拟机之上。或在 PaaS 环境的上下文中。主要原因是大多数组织要么对容器提供的与使用虚拟机管理程序的虚拟机相比缺乏隔离感到不舒服，要么他们还没有适当的技能或工具来管理裸机服务器上的容器.

 

去年，在新兴的“云原生”应用程序以及 IT 组织希望将现有遗留应用程序“容器化”以更轻松地将其提升并转移到云中的情况下，容器的使用急剧加速。随着云原生开发方法的采用成熟，现在确实是容器何时（而不是是否）成为应用程序交付的事实标准的一个案例。

 

IT 组织接下来面临的挑战将是弄清楚如何最好地管理容器化应用程序以及在旧平台上运行的所有现有应用程序，这些应用程序不太可能很快被淘汰。