[{"id":0,"href":"/kubernetes/docs/%E7%AC%AC%E4%B8%80%E7%AB%A0-kubernetes-%E7%AE%80%E4%BB%8B/1.1-kubernetes%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2/","title":"1.1 kubernetes发展历史","section":"第一章 kubernetes 简介","content":"Kubernetes源于 Google 内部的 Borg 项目，经 Google 使用 Go 语言重写后，被命名为 Kubernetes，并于 2014 年 6 月开源。\nKubernetes 希腊语为“舵手”，致力于管理数以万计的容器集群，开源之前在 Google 内部的项目名为“九之七项目”（Project Seven of Nine），这也正是 Kubernetes 的 Logo 有七条边的寓意。\n"},{"id":1,"href":"/kubernetes/docs/%E5%86%99%E4%BD%9C%E8%83%8C%E6%99%AF/","title":"写作背景","section":"Docs","content":"补充：\n1、简要概述k8s诞生历史\n2、强调k8s重要性\n背景：\n1）kubernetes二次开发资料零碎，并没有系统的介绍\n2）kubernetes二次开发也没有贴近代码实战性的介绍\n"},{"id":2,"href":"/kubernetes/docs/%E7%AC%AC%E4%B8%80%E7%AB%A0-kubernetes-%E7%AE%80%E4%BB%8B/","title":"第一章 kubernetes 简介","section":"Docs","content":"Kubernetes 是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。 Kubernetes 拥有一个庞大且快速增长的生态系统。Kubernetes 的服务、支持和工具广泛可用。\nKubernetes 这个名字源于希腊语，意为“舵手”或“飞行员”。k8s 这个缩写是因为 k 和 s 之间有八个字符的关系。 Google 在 2014 年开源了 Kubernetes 项目。Kubernetes 建立在 Google 在大规模运行生产工作负载方面拥有十几年的经验 的基础上，结合了社区中最好的想法和实践。\n时光回溯 让我们回顾一下为什么 Kubernetes 如此有用。 部署演进\n传统部署时代：\n早期，各个组织机构在物理服务器上运行应用程序。无法为物理服务器中的应用程序定义资源边界，这会导致资源分配问题。 例如，如果在物理服务器上运行多个应用程序，则可能会出现一个应用程序占用大部分资源的情况， 结果可能导致其他应用程序的性能下降。 一种解决方案是在不同的物理服务器上运行每个应用程序，但是由于资源利用不足而无法扩展， 并且维护许多物理服务器的成本很高。\n虚拟化部署时代：\n作为解决方案，引入了虚拟化。虚拟化技术允许你在单个物理服务器的 CPU 上运行多个虚拟机（VM）。 虚拟化允许应用程序在 VM 之间隔离，并提供一定程度的安全，因为一个应用程序的信息 不能被另一应用程序随意访问。\n虚拟化技术能够更好地利用物理服务器上的资源，并且因为可轻松地添加或更新应用程序 而可以实现更好的可伸缩性，降低硬件成本等等。\n每个 VM 是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。\n容器部署时代：\n容器类似于 VM，但是它们具有被放宽的隔离属性，可以在应用程序之间共享操作系统（OS）。 因此，容器被认为是轻量级的。容器与 VM 类似，具有自己的文件系统、CPU、内存、进程空间等。 由于它们与基础架构分离，因此可以跨云和 OS 发行版本进行移植。\n容器因具有许多优势而变得流行起来。下面列出的是容器的一些好处：\n敏捷应用程序的创建和部署：与使用 VM 镜像相比，提高了容器镜像创建的简便性和效率。 持续开发、集成和部署：通过快速简单的回滚（由于镜像不可变性），支持可靠且频繁的 容器镜像构建和部署。 关注开发与运维的分离：在构建/发布时而不是在部署时创建应用程序容器镜像， 从而将应用程序与基础架构分离。 可观察性：不仅可以显示操作系统级别的信息和指标，还可以显示应用程序的运行状况和其他指标信号。 跨开发、测试和生产的环境一致性：在便携式计算机上与在云中相同地运行。 跨云和操作系统发行版本的可移植性：可在 Ubuntu、RHEL、CoreOS、本地、 Google Kubernetes Engine 和其他任何地方运行。 以应用程序为中心的管理：提高抽象级别，从在虚拟硬件上运行 OS 到使用逻辑资源在 OS 上运行应用程序。 松散耦合、分布式、弹性、解放的微服务：应用程序被分解成较小的独立部分， 并且可以动态部署和管理 - 而不是在一台大型单机上整体运行。 资源隔离：可预测的应用程序性能。 资源利用：高效率和高密度。 为什么需要 Kubernetes，它能做什么? 容器是打包和运行应用程序的好方式。在生产环境中，你需要管理运行应用程序的容器，并确保不会停机。 例如，如果一个容器发生故障，则需要启动另一个容器。如果系统处理此行为，会不会更容易？\n这就是 Kubernetes 来解决这些问题的方法！ Kubernetes 为你提供了一个可弹性运行分布式系统的框架。 Kubernetes 会满足你的扩展要求、故障转移、部署模式等。 例如，Kubernetes 可以轻松管理系统的 Canary 部署。\nKubernetes 为你提供：\n服务发现和负载均衡\nKubernetes 可以使用 DNS 名称或自己的 IP 地址公开容器，如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。\n存储编排\nKubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。\n自动部署和回滚\n你可以使用 Kubernetes 描述已部署容器的所需状态，它可以以受控的速率将实际状态 更改为期望状态。例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。\n自动完成装箱计算\nKubernetes 允许你指定每个容器所需 CPU 和内存（RAM）。 当容器指定了资源请求时，Kubernetes 可以做出更好的决策来管理容器的资源。\n自我修复\nKubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的 运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。\n密钥与配置管理\nKubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。\nKubernetes 不是什么 Kubernetes 不是传统的、包罗万象的 PaaS（平台即服务）系统。 由于 Kubernetes 在容器级别而不是在硬件级别运行，它提供了 PaaS 产品共有的一些普遍适用的功能， 例如部署、扩展、负载均衡、日志记录和监视。 但是，Kubernetes 不是单体系统，默认解决方案都是可选和可插拔的。 Kubernetes 提供了构建开发人员平台的基础，但是在重要的地方保留了用户的选择和灵活性。\nKubernetes：\n不限制支持的应用程序类型。 Kubernetes 旨在支持极其多种多样的工作负载，包括无状态、有状态和数据处理工作负载。 如果应用程序可以在容器中运行，那么它应该可以在 Kubernetes 上很好地运行。 不部署源代码，也不构建你的应用程序。 持续集成(CI)、交付和部署（CI/CD）工作流取决于组织的文化和偏好以及技术要求。 不提供应用程序级别的服务作为内置服务，例如中间件（例如，消息中间件）、 数据处理框架（例如，Spark）、数据库（例如，mysql）、缓存、集群存储系统 （例如，Ceph）。这样的组件可以在 Kubernetes 上运行，并且/或者可以由运行在 Kubernetes 上的应用程序通过可移植机制（例如， 开放服务代理）来访问。 不要求日志记录、监视或警报解决方案。 它提供了一些集成作为概念证明，并提供了收集和导出指标的机制。 不提供或不要求配置语言/系统（例如 jsonnet），它提供了声明性 API， 该声明性 API 可以由任意形式的声明性规范所构成。 不提供也不采用任何全面的机器配置、维护、管理或自我修复系统。 此外，Kubernetes 不仅仅是一个编排系统，实际上它消除了编排的需要。 编排的技术定义是执行已定义的工作流程：首先执行 A，然后执行 B，再执行 C。 相比之下，Kubernetes 包含一组独立的、可组合的控制过程， 这些过程连续地将当前状态驱动到所提供的所需状态。 如何从 A 到 C 的方式无关紧要，也不需要集中控制，这使得系统更易于使用 且功能更强大、系统更健壮、更为弹性和可扩展。\n"},{"id":3,"href":"/kubernetes/docs/%E7%AC%AC%E4%BA%8C%E7%AB%A0-kubernetes-%E9%9B%86%E7%BE%A4/","title":"第二章 kubernetes 集群搭建","section":"Docs","content":"Introduction #  "},{"id":4,"href":"/kubernetes/docs/%E7%AC%AC%E4%B8%89%E7%AB%A0-kubernetes-operator%E5%BC%80%E5%8F%91/","title":"第三章 kubernetes operator开发","section":"Docs","content":"Introduction #  "},{"id":5,"href":"/kubernetes/docs/%E7%AC%AC%E5%9B%9B%E7%AB%A0-kubernetes-kubelet%E5%BC%80%E5%8F%91/","title":"第四章 kubernetes kubelet开发","section":"Docs","content":"引言 #  计算、存储、网络\n"},{"id":6,"href":"/kubernetes/docs/%E7%AC%AC%E4%BA%8C%E7%AB%A0-kubernetes-%E9%9B%86%E7%BE%A4/kubernetes%E5%AD%A6%E4%B9%A0%E5%BC%80%E6%BA%90%E5%9C%A8%E7%BA%BF/","title":"2.1 kubernetes学习开源在线","section":"第二章 kubernetes 集群搭建","content":"介绍 #  "},{"id":7,"href":"/kubernetes/docs/%E7%AC%AC%E4%BA%8C%E7%AB%A0-kubernetes-%E9%9B%86%E7%BE%A4/kubernetes%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","title":"2.2 kubernetes环境搭建","section":"第二章 kubernetes 集群搭建","content":"介绍 #  "},{"id":8,"href":"/kubernetes/docs/%E7%AC%AC%E4%BA%8C%E7%AB%A0-kubernetes-%E9%9B%86%E7%BE%A4/kubernetes%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","title":"2.3 kubernetes高可用集群环境搭建","section":"第二章 kubernetes 集群搭建","content":"介绍 #  "},{"id":9,"href":"/kubernetes/docs/%E7%AC%AC%E4%BA%8C%E7%AB%A0-kubernetes-%E9%9B%86%E7%BE%A4/kubernetes%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/","title":"2.4 kubernetes日志系统","section":"第二章 kubernetes 集群搭建","content":"介绍 #  "},{"id":10,"href":"/kubernetes/docs/%E7%AC%AC%E4%BA%8C%E7%AB%A0-kubernetes-%E9%9B%86%E7%BE%A4/kubernetes%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/","title":"2.5 kubernetes监控系统","section":"第二章 kubernetes 集群搭建","content":"介绍 #  "},{"id":11,"href":"/kubernetes/docs/%E7%AC%AC%E5%9B%9B%E7%AB%A0-kubernetes-kubelet%E5%BC%80%E5%8F%91/4.1-%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%8E%A5%E5%8F%A3cri/","title":"4.1 容器运行时接口CRI","section":"第四章 kubernetes kubelet开发","content":"容器运行时是现代容器化架构的基础组件，容器运行时接口 (CRI) 是一个插件接口，它允许 kubelet（Kubernetes 集群中每个节点上运行的代理）使用多种容器运行时。\nCRI 最初是在 Kubernetes v1.5 中引入的；在引入 CRI 之前，kubernetes 直接将rkt 和 Docker 集成到 kubelet 的源代码中的，这使得用户将新的容器运行时与 Kubernetes 集成变得异常困难。 CRI就是在这种背景下诞生的，一方面kubernetes抽象出通用插件接口，专注于调度等功能，一方面，将适配工作下沉到了各个容器运行时开发人员。CRI 使 Kubernetes 用户能够轻松使用多个容器运行时，并使容器运行时的开发人员能够轻松地将它们与 Kubernetes 生态系统集成。\n"},{"id":12,"href":"/kubernetes/docs/%E7%AC%AC%E5%9B%9B%E7%AB%A0-kubernetes-kubelet%E5%BC%80%E5%8F%91/4.2-%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3cni/","title":"4.2 容器网络接口CNI","section":"第四章 kubernetes kubelet开发","content":"Introduction #  "},{"id":13,"href":"/kubernetes/docs/%E7%AC%AC%E5%9B%9B%E7%AB%A0-kubernetes-kubelet%E5%BC%80%E5%8F%91/4.3-%E5%99%A8%E5%AD%98%E5%82%A8%E6%8E%A5%E5%8F%A3csi/","title":"4.3 容器存储接口CSI","section":"第四章 kubernetes kubelet开发","content":"Introduction #  "},{"id":14,"href":"/kubernetes/docs/%E7%AC%AC%E5%9B%9B%E7%AB%A0-kubernetes-kubelet%E5%BC%80%E5%8F%91/4.1-%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%8E%A5%E5%8F%A3cri/%E5%AE%B9%E5%99%A8%E5%8C%96%E5%8F%91%E5%B1%95/","title":"4.1.1 容器化发展","section":"4.1 容器运行时接口CRI","content":" container（容器）英文单词又叫集装箱；1956年4月26号，麦克莱恩发明集装箱，随后集装箱就开始极大地推动了全球化的协作浪潮，为更快、更便宜和更可靠的全球化运输铺平了道路，使得制造业的产业链条发生了翻天覆地的变化。\n 在许多方面，与物理容器（集装箱）如何塑造航运一样，应用程序容器也在彻底改变软件的开发与运作。与物理容器相似，应用程序容器是数字包装的一种形式。他们依靠该属性为部署或运行使用相同操作系统 (OS) 或云的各种应用程序提供虚拟隔离。\n 容器的最初想法要追溯到20世纪七十年代，那时计算机还是一种稀有商品，光是租一个，每月就要花费一千多美元，这让许多企业望而却步；那个年代的一千多美元相当于现在一万美元左右。为了应对这种情况，人们已经发明了多个计算机终端连接到一个中央大型机器，这样便可以在一台中心机器完成工作。集中式计算机使从一个位置控制所有任务成为可能，因此如果一个终端出现故障，用户只需转到另一个终端，在那里登录，仍然可以访问他们的所有文件。然而，这样确有一些缺点。例如，如果因某种原因或是有人蓄意造成中央计算机崩溃，系统会导致所有人都无法使用。像这样的问题表明，计算机不仅需要能够分离出单个用户，还需要能够分离出系统进程。\n 为了隔离环境，1979年，贝尔实验室chroot(change root)系统调用程序正式引入Unix V7的开发过程中。它为每个进程提供一个独立的磁盘空间，将一个进程及其子进程的根目录拷贝到文件系统的新位置，让这些进程只能访问这些目录。但是令人感到惋惜的是Unix v7是贝尔实验室发布的最后一个免费版本，之后开始收回版权，进行商业化。也正是因为这个原因，Richard Matthew Stallman 在 1983 年发起 GUN（GNU's Not UNIX） 计划和自由软件运动。\n 2000 年 3 月 4 日，FreeBSD 将 jail 命令引入其操作系统。虽然它类似于 chroot 命令，但它还包括用于隔离文件系统、用户、网络等的附加进程沙盒功能。在进程来看，跟实际的操作系统几乎是一样的，对进程来说就像被关进了监狱，这也是jail名称的由来。FreeBSD jail 使我们能够分配 IP 地址、配置自定义软件安装以及对每个 jail 进行修改。chroot开创了进程隔离的思想，但FreeBSD Jails才是真正实现了进程的沙箱化。\n 2004 年，我们看到了 Solaris 容器的发布，它通过使用 Solaris Zones 创建了完整的应用程序环境。使用区域，您可以为应用程序提供完整的用户、进程和文件系统空间，以及对系统硬件的访问权限。但是，该应用程序只能看到它自己区域内的内容。2006 年，Google 的工程师宣布他们推出了用于隔离和限制进程资源使用的进程容器。 2007 年，这些容器被重命名为控制组 (cgroups)，并集成到了Linux内核。\n 2008 年，通过将 Cgroups 的资源管理能力和 Linux Namespace 的视图隔离能力组合在一起， LXC（Linux Container） 这样的完整的容器技术出现在了 Linux 内核当中。它是第一个完善的容器管理方案，你可以通过 LXC 来创建和启动容器了。 LXC 跟之前出现的沙盒技术非常类似，但其赶上了 Linux 大规模商用的浪潮。伴随着公有云市场的崛起，很快催生了一个全新的、名为 PaaS 的产业。\n 2013 年，Docker 基于 LXC 发布第一个版本，并提出了镜像技术，通过了build、ship、run的概念，创造了一次构建、处处运行的新思想，将容器技术向IT产业链条的上游和下游进行了延伸。\n 另外在容器镜像的制作上还借鉴git思想引入了“层”的概念，通过build，push，update 等操作将镜像托管到 DockerHub 这样的仓库，这样软件就可以实现分发了。\n 2014年，Google工程师和Docker合作开发 libcontainer，并将此库代替了原来的 LXC 。CoreOS发布并开始支持rkt（最初作为Rocket发布），旨在提供一个比 Docker 更严格的安全性和产品需求。更重要的是，它是在一个更加开放的标准 AppContainer 规范上实现的。\n 2015 年，在 Linux 基金会的支持下成立了 OCI（Open Constitution Initiative） 。OCI 致力于围绕容器镜像格式和容器运行时建立开发的行业标准，让容器可以在各种兼容性的操作系统和平台上移植，没有人为的技术屏障。\n 2016 年 Docker 发布了 1.11 版本，做了一些架构调整，里面新出现了符合 OCI 标准的 runC 。runC 其实就是对 libcontainer 的调用，是一种符合开放式容器格式标准的一种实现，后来 Docker 就把 runC 贡献出来了。\n 随着容器技术的不断发展，容器化在商业上也进入了快速发展期。2017 年 - 2018 年，AWS ECS，Google EKS，Alibaba ACK/ASK/ECI，华为 CCI，Oracle Container Engine for Kubernetes；VMware，Redhat 和 Rancher 都开始提供基于 Kubernetes 的商业服务产品。\n 尽管容器技术炙手可热，在商业领域大放光彩，但遇到的挑战还是很大。对于容器问题的挑战，tripwire Ali Golshan 发布了一个每家公司面临的 5 大容器安全风险。\n1、使用不安全的镜像 2、使用特权标志运行的容器 3、容器间无限制通信 4、运行流氓或恶意进程的容器 5、与宿主机隔离不当的容器   针对容器安全风险，目前业界的方案是提供一种隔离层，让应用容器运行在自己的内核之上，不与其他容器共享。\n 基于VM的方案，该方案不需要对当前的软件技术栈进行改动，让同一个用户容器在自己的虚拟机里运行，虽然可以解决安全问题，但是会造成额外的资源开销和运维维护复杂。\n 基于LibOs的方案，该方案让应用控制自己的内核，增大了应用的维护难度，并且平台兼容性也会遇到很大的挑战，难以推广。\n 基于MicroVM的方案，使用了轻量级虚机和裁剪过的 Linux 内核，在保证兼容性的前提下尽量降低运行时和维护的开销。2017年底，Kata Containers 社区成立；VMworld 2019 发布 Project Pacific；2019年七月Intel发布了Cloud Hypervisor；2021年微软发布了WSL 2 （Windows Subsystem for Linux 2）；2018年3月AWS发布Firecracker；2018 年 11 月阿里云发布安全沙箱 1.0。\n 基于进程虚拟化的方案，使用一个特定的内核来提供 Linux ABI，直接虚拟化进程的运行环境，为 Linux 应用尽量提供最大兼容性。2018 年 5 月 Google 开源 gVisor。\n 参考\nhttps://d2iq.com/blog/brief-history-containers\nhttps://www.dataversity.net/a-brief-history-of-data-containers/#\nhttps://acloudguru.com/blog/engineering/history-of-container-technology\nhttps://www.infoq.cn/article/ss6sitklgolexqp4umr5\nhttp://liupzmin.com/2019/11/06/docker/container-chat/\nhttps://www.tripwire.com/state-of-security/devops/5-container-security-risks-every-company-faces/\nhttps://developer.aliyun.com/article/775778\nhttps://developer.aliyun.com/article/719686\n"},{"id":15,"href":"/kubernetes/docs/%E7%AC%AC%E5%9B%9B%E7%AB%A0-kubernetes-kubelet%E5%BC%80%E5%8F%91/4.1-%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%8E%A5%E5%8F%A3cri/kubernetes%E5%AE%B9%E5%99%A8%E5%8C%96%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8F%91%E5%B1%95/","title":"4.1.2 kubernetes容器化运行时发展","section":"4.1 容器运行时接口CRI","content":"Docker的诞生和容器镜像的引入，使得软件制作变得异常容易；它解决了软件通过什么样的方式进行交互问题。然而仅仅是只有容器并不能产生很大的价值，就像集装箱一样，本身就是个大铁盒子，它没有太多价值，单单靠它提高不了社会协作的效能。它只有流动起来，才会产生价值，把货物从一个车间运到另一个车间，这种连接才是其价值所在。容器也一样，本身没有太多商业价值，你弄得再完美，你也只能在一个服务器上折腾，翻不出多大的浪花，那怎么样才能产生价值呢？\n那就是真正价值所在——容器编排！\n在既有硬件资源的基础上，启动容器不需要关注具体运行的节点，各个容器之间仍能保持通信，信息在容器之间依然可以流动。这样就拥有了商业价值，容器技术便可以付诸商用，整个软件的开发交付流程就会变得高效和颠覆。所以我们需要的是一个分布式的调度器，其主要功能就是容器编排。\nDocker公司也深知这一点， 2015 年 Swarm 进入编排领域；但是在2014年6月Google发布了kubernetes，它源于内部的Borg项目，后经Go语言重写后开源。Kubernetes 希腊语意思是“舵手”，致力于管理数以万计的容器集群。你看舵手不正是隐喻了方向和流动么。因其开头字母和结尾字母之间共有 8 个字，所以简短的称其为k8s。\n2014 年 k8s 开源之后，同年底 Docker 就设计了 machine+swarm+compose 的组合方案。2015 年 7 月 k8s 发布了第一个商用版本 1.0 ，同一年 Docker 的 Swarm 发布，编排大战已经开始上演了。\n2016 年 2 月 Docker 发布了 1.12 版本，它不顾众怒，将 Swarm 强行内置到 Docker 的容器引擎里面，企图利用 Docker 项目在容器领域的领导地位推动 Swarm 的发展。这有点像什么？举个不恰当的例子，我订购了一个集装箱，你却附赠了一个不太好用的货轮。这一下一石惊起千层浪，业界都纷纷谴责 Docker 。同年的 7 月 Apache mesos 发布了 1.0 ，也是一个容器编排框架，至此，Kubernetes、Docker Swarm 和 Apache Mesos 已成三足鼎立之势。\n然而，2017 年 9 月，Mesosphere 宣布支持 Kubernetes，这也是迫于用户压力，在对抗和妥协面前，不得不选择后者。\n2017 年 10 月，在欧洲的 DockerCon 大会上，Docker 公司 CTO Solomon Hykes 宣布，Docker 的下个版本将支持 Kubernetes，台下观众响起热烈掌声，因为这是容器圈等待已久的消息。\nKubernetes 在众多厂商和开源爱好者的共同努力下迅速崛起，时至今日已成长为容器管理领域的事实标准。Kubernetes 极大推动了云原生领域的发展，被称为影响云计算未来 10 年的技术。\n因起初Docker容器占据很重要的工作，kubernetes在节点管理组件kubelet进行了大量的适配，后来随着容器化领域的不断完善和发展以及CRI、OCI等标准接口的定义，标志着kubernetes成为事实的标准。\n下图是kubernetes支持的主流容器示意图\n"},{"id":16,"href":"/kubernetes/docs/%E7%AC%AC%E5%9B%9B%E7%AB%A0-kubernetes-kubelet%E5%BC%80%E5%8F%91/4.1-%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%8E%A5%E5%8F%A3cri/%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3/","title":"4.1.3 容器运行时接口详解","section":"4.1 容器运行时接口CRI","content":"什么是CRI #  CRI是Kubelet（负责管理容器生命周期的服务）与容器引擎之间的接口。为了适应多种不同的容器引擎，Kubelet在加入rkt的时候就已经在docker API的基础上抽象了一个Runtime接口，只是由于一些特定的缺陷，在这个接口上不太容易引入其他新的容器引擎：\nRuntime接口的抽象度太高，导致一些原本该在Kubelet控制的逻辑被放到了Runtime实现里面。比如在当前的实现中，rkt和docker的SyncPod（负责Pod创建的接口）存在大量重复的逻辑，每次修改docker部分的时，都有可能需要同时修改rkt部分。这样，如果再加入新的容器引擎的话，同时修改多个Runtime部分的代码是没法维护的。 Runtime接口是集成在Kubelet内部的，集成容器引擎相关的代码需要放到Kubernetes代码库里面，这同样带来了维护的问题：代码维护麻烦，任何一个容器引擎修改了代码都需要发布新的kubelet；集成测试麻烦，要为每个不同的容器引擎部署不同的集成测试环境。 没有提供容器创建的接口，无法直接在Kubelet里面做到对容器的精细控制。 耦合了镜像和容器管理，而它们的生命周期本来就是独立的。 既然Runtime接口有很多问题，并且有很多容器引擎想要集成到Kubernetes中，所以有必要重新定义CRI，并且提供一种插件机制，允许容器引擎以外部独立进程的方式接入。所以，Brendan Burns在Hyper集成的时候就提供了一种以客户端/服务器方式接入外部容器引擎的思路。在大量的社区讨论后，Node team重新抽象了容器引擎接口（也就是CRI），并决定以gRPC的方式接入外部容器引擎。\nCRI是如何工作的 #  CRI比Runtime接口提供了更细粒度的抽象，解耦了镜像管理和容器管理，并为Pod和Container提供了独立的操作接口。CRI以gRPC的方式接入，Kubelet是gPRC API的客户端，而容器引擎则是gRPC API的服务端。gRPC已经自动实现了它们之间交互的细节，容器引擎只需要实现每个具体的API。\n参考： https://feisky.xyz/posts/2016-09-25-kubernetes-container-runtime-interface/\n"},{"id":17,"href":"/kubernetes/docs/%E7%AC%AC%E5%9B%9B%E7%AB%A0-kubernetes-kubelet%E5%BC%80%E5%8F%91/4.1-%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%8E%A5%E5%8F%A3cri/%E5%BC%80%E6%BA%90%E7%A4%BE%E5%8C%BA%E7%8E%B0%E7%8A%B6/","title":"4.1.4 开源社区现状","section":"4.1 容器运行时接口CRI","content":"Introduction #  "},{"id":18,"href":"/kubernetes/docs/%E7%AC%AC%E5%9B%9B%E7%AB%A0-kubernetes-kubelet%E5%BC%80%E5%8F%91/4.1-%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%8E%A5%E5%8F%A3cri/cri%E6%8E%A5%E5%8F%A3%E5%AE%9E%E6%88%98/","title":"4.1.5 CRI接口实战","section":"4.1 容器运行时接口CRI","content":"Introduction #  "},{"id":19,"href":"/kubernetes/docs/%E7%AC%AC%E4%B8%80%E7%AB%A0-kubernetes-%E7%AE%80%E4%BB%8B/1.2-kubernetes%E6%9E%B6%E6%9E%84/kubernetes%E6%9E%B6%E6%9E%84%E5%9B%BE/","title":"Kubernetes架构图","section":"1.2 kubernetes架构","content":"test #  "},{"id":20,"href":"/kubernetes/docs/%E7%AC%AC%E4%B8%80%E7%AB%A0-kubernetes-%E7%AE%80%E4%BB%8B/1.2-kubernetes%E6%9E%B6%E6%9E%84/kubernetes%E7%BB%84%E4%BB%B6/","title":"Kubernetes组件","section":"1.2 kubernetes架构","content":"test #  "}]