[{"id":0,"href":"/kubernetes/docs/%E7%AC%AC%E4%B8%80%E7%AB%A0-kubernetes-%E7%AE%80%E4%BB%8B/1.1-kubernetes%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2/","title":"1.1 kubernetes发展历史","section":"第一章 kubernetes 简介","content":"Kubernetes源于 Google 内部的 Borg 项目，经 Google 使用 Go 语言重写后，被命名为 Kubernetes，并于 2014 年 6 月开源。\nKubernetes 希腊语为“舵手”，致力于管理数以万计的容器集群，开源之前在 Google 内部的项目名为“九之七项目”（Project Seven of Nine），这也正是 Kubernetes 的 Logo 有七条边的寓意。\n"},{"id":1,"href":"/kubernetes/docs/%E5%86%99%E4%BD%9C%E8%83%8C%E6%99%AF/","title":"写作背景","section":"Docs","content":"补充：\n1、简要概述k8s诞生历史\n2、强调k8s重要性\n背景：\n1）kubernetes二次开发资料零碎，并没有系统的介绍\n2）kubernetes二次开发也没有贴近代码实战性的介绍\n"},{"id":2,"href":"/kubernetes/docs/%E7%AC%AC%E4%B8%80%E7%AB%A0-kubernetes-%E7%AE%80%E4%BB%8B/","title":"第一章 kubernetes 简介","section":"Docs","content":"Kubernetes 是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。 Kubernetes 拥有一个庞大且快速增长的生态系统。Kubernetes 的服务、支持和工具广泛可用。\nKubernetes 这个名字源于希腊语，意为“舵手”或“飞行员”。k8s 这个缩写是因为 k 和 s 之间有八个字符的关系。 Google 在 2014 年开源了 Kubernetes 项目。Kubernetes 建立在 Google 在大规模运行生产工作负载方面拥有十几年的经验 的基础上，结合了社区中最好的想法和实践。\n时光回溯 让我们回顾一下为什么 Kubernetes 如此有用。 部署演进\n传统部署时代：\n早期，各个组织机构在物理服务器上运行应用程序。无法为物理服务器中的应用程序定义资源边界，这会导致资源分配问题。 例如，如果在物理服务器上运行多个应用程序，则可能会出现一个应用程序占用大部分资源的情况， 结果可能导致其他应用程序的性能下降。 一种解决方案是在不同的物理服务器上运行每个应用程序，但是由于资源利用不足而无法扩展， 并且维护许多物理服务器的成本很高。\n虚拟化部署时代：\n作为解决方案，引入了虚拟化。虚拟化技术允许你在单个物理服务器的 CPU 上运行多个虚拟机（VM）。 虚拟化允许应用程序在 VM 之间隔离，并提供一定程度的安全，因为一个应用程序的信息 不能被另一应用程序随意访问。\n虚拟化技术能够更好地利用物理服务器上的资源，并且因为可轻松地添加或更新应用程序 而可以实现更好的可伸缩性，降低硬件成本等等。\n每个 VM 是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。\n容器部署时代：\n容器类似于 VM，但是它们具有被放宽的隔离属性，可以在应用程序之间共享操作系统（OS）。 因此，容器被认为是轻量级的。容器与 VM 类似，具有自己的文件系统、CPU、内存、进程空间等。 由于它们与基础架构分离，因此可以跨云和 OS 发行版本进行移植。\n容器因具有许多优势而变得流行起来。下面列出的是容器的一些好处：\n敏捷应用程序的创建和部署：与使用 VM 镜像相比，提高了容器镜像创建的简便性和效率。 持续开发、集成和部署：通过快速简单的回滚（由于镜像不可变性），支持可靠且频繁的 容器镜像构建和部署。 关注开发与运维的分离：在构建/发布时而不是在部署时创建应用程序容器镜像， 从而将应用程序与基础架构分离。 可观察性：不仅可以显示操作系统级别的信息和指标，还可以显示应用程序的运行状况和其他指标信号。 跨开发、测试和生产的环境一致性：在便携式计算机上与在云中相同地运行。 跨云和操作系统发行版本的可移植性：可在 Ubuntu、RHEL、CoreOS、本地、 Google Kubernetes Engine 和其他任何地方运行。 以应用程序为中心的管理：提高抽象级别，从在虚拟硬件上运行 OS 到使用逻辑资源在 OS 上运行应用程序。 松散耦合、分布式、弹性、解放的微服务：应用程序被分解成较小的独立部分， 并且可以动态部署和管理 - 而不是在一台大型单机上整体运行。 资源隔离：可预测的应用程序性能。 资源利用：高效率和高密度。 为什么需要 Kubernetes，它能做什么? 容器是打包和运行应用程序的好方式。在生产环境中，你需要管理运行应用程序的容器，并确保不会停机。 例如，如果一个容器发生故障，则需要启动另一个容器。如果系统处理此行为，会不会更容易？\n这就是 Kubernetes 来解决这些问题的方法！ Kubernetes 为你提供了一个可弹性运行分布式系统的框架。 Kubernetes 会满足你的扩展要求、故障转移、部署模式等。 例如，Kubernetes 可以轻松管理系统的 Canary 部署。\nKubernetes 为你提供：\n服务发现和负载均衡\nKubernetes 可以使用 DNS 名称或自己的 IP 地址公开容器，如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。\n存储编排\nKubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。\n自动部署和回滚\n你可以使用 Kubernetes 描述已部署容器的所需状态，它可以以受控的速率将实际状态 更改为期望状态。例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。\n自动完成装箱计算\nKubernetes 允许你指定每个容器所需 CPU 和内存（RAM）。 当容器指定了资源请求时，Kubernetes 可以做出更好的决策来管理容器的资源。\n自我修复\nKubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的 运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。\n密钥与配置管理\nKubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。\nKubernetes 不是什么 Kubernetes 不是传统的、包罗万象的 PaaS（平台即服务）系统。 由于 Kubernetes 在容器级别而不是在硬件级别运行，它提供了 PaaS 产品共有的一些普遍适用的功能， 例如部署、扩展、负载均衡、日志记录和监视。 但是，Kubernetes 不是单体系统，默认解决方案都是可选和可插拔的。 Kubernetes 提供了构建开发人员平台的基础，但是在重要的地方保留了用户的选择和灵活性。\nKubernetes：\n不限制支持的应用程序类型。 Kubernetes 旨在支持极其多种多样的工作负载，包括无状态、有状态和数据处理工作负载。 如果应用程序可以在容器中运行，那么它应该可以在 Kubernetes 上很好地运行。 不部署源代码，也不构建你的应用程序。 持续集成(CI)、交付和部署（CI/CD）工作流取决于组织的文化和偏好以及技术要求。 不提供应用程序级别的服务作为内置服务，例如中间件（例如，消息中间件）、 数据处理框架（例如，Spark）、数据库（例如，mysql）、缓存、集群存储系统 （例如，Ceph）。这样的组件可以在 Kubernetes 上运行，并且/或者可以由运行在 Kubernetes 上的应用程序通过可移植机制（例如， 开放服务代理）来访问。 不要求日志记录、监视或警报解决方案。 它提供了一些集成作为概念证明，并提供了收集和导出指标的机制。 不提供或不要求配置语言/系统（例如 jsonnet），它提供了声明性 API， 该声明性 API 可以由任意形式的声明性规范所构成。 不提供也不采用任何全面的机器配置、维护、管理或自我修复系统。 此外，Kubernetes 不仅仅是一个编排系统，实际上它消除了编排的需要。 编排的技术定义是执行已定义的工作流程：首先执行 A，然后执行 B，再执行 C。 相比之下，Kubernetes 包含一组独立的、可组合的控制过程， 这些过程连续地将当前状态驱动到所提供的所需状态。 如何从 A 到 C 的方式无关紧要，也不需要集中控制，这使得系统更易于使用 且功能更强大、系统更健壮、更为弹性和可扩展。\n"},{"id":3,"href":"/kubernetes/docs/%E7%AC%AC%E4%BA%8C%E7%AB%A0-kubernetes-%E9%9B%86%E7%BE%A4/","title":"第二章 kubernetes 集群搭建","section":"Docs","content":"Introduction #  "},{"id":4,"href":"/kubernetes/docs/%E7%AC%AC%E4%B8%89%E7%AB%A0-kubernetes-operator%E5%BC%80%E5%8F%91/","title":"第三章 kubernetes operator开发","section":"Docs","content":"Introduction #  "},{"id":5,"href":"/kubernetes/docs/%E7%AC%AC%E5%9B%9B%E7%AB%A0-kubernetes-kubelet%E5%BC%80%E5%8F%91/","title":"第四章 kubernetes kubelet开发","section":"Docs","content":"引言 #  计算、存储、网络\n"},{"id":6,"href":"/kubernetes/docs/%E7%AC%AC%E4%BA%8C%E7%AB%A0-kubernetes-%E9%9B%86%E7%BE%A4/kubernetes%E5%AD%A6%E4%B9%A0%E5%BC%80%E6%BA%90%E5%9C%A8%E7%BA%BF/","title":"2.1 kubernetes学习开源在线","section":"第二章 kubernetes 集群搭建","content":"介绍 #  "},{"id":7,"href":"/kubernetes/docs/%E7%AC%AC%E4%BA%8C%E7%AB%A0-kubernetes-%E9%9B%86%E7%BE%A4/kubernetes%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","title":"2.2 kubernetes环境搭建","section":"第二章 kubernetes 集群搭建","content":"介绍 #  "},{"id":8,"href":"/kubernetes/docs/%E7%AC%AC%E4%BA%8C%E7%AB%A0-kubernetes-%E9%9B%86%E7%BE%A4/kubernetes%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","title":"2.3 kubernetes高可用集群环境搭建","section":"第二章 kubernetes 集群搭建","content":"介绍 #  "},{"id":9,"href":"/kubernetes/docs/%E7%AC%AC%E4%BA%8C%E7%AB%A0-kubernetes-%E9%9B%86%E7%BE%A4/kubernetes%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/","title":"2.4 kubernetes日志系统","section":"第二章 kubernetes 集群搭建","content":"介绍 #  "},{"id":10,"href":"/kubernetes/docs/%E7%AC%AC%E4%BA%8C%E7%AB%A0-kubernetes-%E9%9B%86%E7%BE%A4/kubernetes%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/","title":"2.5 kubernetes监控系统","section":"第二章 kubernetes 集群搭建","content":"介绍 #  "},{"id":11,"href":"/kubernetes/docs/%E7%AC%AC%E5%9B%9B%E7%AB%A0-kubernetes-kubelet%E5%BC%80%E5%8F%91/4.1-%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%8E%A5%E5%8F%A3cri/","title":"4.1 容器运行时接口CRI","section":"第四章 kubernetes kubelet开发","content":"容器运行时接口 (CRI) 是一个插件接口，它允许 kubelet（在 Kubernetes 集群中的每个节点上运行的代理）使用多种容器运行时。容器运行时是现代容器化架构的基础组件。\nCRI 最初是在 Kubernetes v1.5 中引入的。在引入 CRI 之前，rkt 和 Docker 是直接集成到 kubelet 的源代码中的。这使得将新的容器运行时与 Kubernetes 集成变得困难。 CRI 使 Kubernetes 用户能够轻松使用多个容器运行时，并使容器运行时的开发人员能够轻松地将它们与 Kubernetes 生态系统集成。\n"},{"id":12,"href":"/kubernetes/docs/%E7%AC%AC%E5%9B%9B%E7%AB%A0-kubernetes-kubelet%E5%BC%80%E5%8F%91/4.2-%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3cni/","title":"4.2 容器网络接口CNI","section":"第四章 kubernetes kubelet开发","content":"Introduction #  "},{"id":13,"href":"/kubernetes/docs/%E7%AC%AC%E5%9B%9B%E7%AB%A0-kubernetes-kubelet%E5%BC%80%E5%8F%91/4.3-%E5%99%A8%E5%AD%98%E5%82%A8%E6%8E%A5%E5%8F%A3csi/","title":"4.3 容器存储接口CSI","section":"第四章 kubernetes kubelet开发","content":"Introduction #  "},{"id":14,"href":"/kubernetes/docs/%E7%AC%AC%E5%9B%9B%E7%AB%A0-kubernetes-kubelet%E5%BC%80%E5%8F%91/4.1-%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%8E%A5%E5%8F%A3cri/%E5%AE%B9%E5%99%A8%E5%8C%96%E5%8F%91%E5%B1%95/","title":"4.1.1 容器化发展","section":"4.1 容器运行时接口CRI","content":"Introduction #  容器可能看起来像是一种突然出现的用于改变 IT 的技术，但实际上它们绝不是新事物。容器的最初想法自 1970 年代就已经存在，当时该概念首次在 Unix 系统上用于更好地隔离应用程序代码。虽然在某些应用程序开发和部署场景中很有用，但容器在早期的最大缺点是一个简单的事实，即它们不是可移植的。\n容器是如何演变的 早在 1970 年代，早期的容器创建了一个隔离的环境，服务和应用程序可以在其中运行而不会干扰其他进程——产生类似于沙盒的东西来测试应用程序、服务和其他进程。最初的想法是将容器的工作负载与生产系统隔离开来，使开发人员能够在生产硬件上测试他们的应用程序和流程，而不会冒中断其他服务的风险。多年来，容器已经获得了隔离用户、文件、网络等的能力。容器现在也可以拥有自己的 IP 地址。\n大约在 2012 年，容器的可用性得到了很大的提升，这要归功于众多 Linux 发行版带来了额外的部署选项和管理工具。在 Linux 平台上运行的容器被转变为操作系统级的虚拟化技术，专门设计用于在单个 Linux 主机上提供多个隔离的 Linux 环境。 Linux 容器不需要专用的客户操作系统；相反，它们共享主机操作系统内核。消除对专用操作系统的需求还允许容器比任何虚拟机更快地启动。\n容器能够使用 Linux 内核特性，如 Namespaces、Apparmor、SELinux 配置文件、chroot 和 CGroups 来创建隔离的操作环境，而 Linux 安全模块增加了一层保护，承诺从容器访问主机和内核防止入侵。容器化的 Linux 风格还通过允许容器从其主机操作系统运行不同的 Linux 发行版来增加更多的灵活性，只要两个操作系统都运行在相同的 CPU 架构上。\nLinux 容器提供了基于各种 Linux 发行版创建容器映像的方法，同时还包含用于管理容器生命周期的 API。 Linux 发行版还包括用于与 API 交互的必要客户端工具、用于拍摄快照的捆绑功能，以及支持将容器实例从一个容器主机迁移到另一个容器主机。\n但是，虽然在 Linux 平台上运行的容器增加了它们的适用性，但仍有几个重大挑战需要克服，包括统一管理、真正的可移植性、兼容性和规模控制。\n清除障碍 随着 Apache Mesos、Google Borg 和 Facebook Tupperware 的到来，Linux 平台上容器的使用开始显着提升，所有这些都带来了不同程度的容器编排和集群管理能力。这些平台提供了按需启动数百个容器的能力，以及对自动故障转移的支持，以及管理容器所需的其他关键任务功能\n 然而，容器不断发展，带来了现在被广泛应用以使企业 IT 更加灵活的抽象功能。由于 Docker 容器的兴起，现在可以更轻松地在不同版本的 Linux 之间移动工作负载，以及编排容器以创建微服务。\n就像容器一样，微服务也不是一个新概念。这个概念可以追溯到面向服务的架构 (SOA)。不同的是，基于容器的微服务更细化，更易于管理。不是通过“修补”它们来更新应用程序，而是通过将现有容器替换为包含新功能的容器来将新功能添加到微服务中。然后，每个微服务都会公开一个应用程序编程接口 (API)，使开发人员能够以编程方式将它们组合在一起，以比以往更快的速度构建应用程序。该方法还有助于简化单个组件的持续维护并增强整体应用程序的安全性。\n显然，构建和维护一系列基于容器的微服务将比维护一个单体应用程序更具挑战性。为了应对这一挑战，出现了各种用于编排在分布式计算环境中运行的容器的平台。\n只有当 IT 组织开始欣赏这些平台提供的功能时，才会清楚容器如何即将成为新抽象层的基础组件，该抽象层有望永远改变企业 IT 的管理方式。\n=========\n作为“没关系成为新人”系列的一部分，本周我一直在对容器进行大量研究。我的目标是为任何人（无论技术背景如何）打下基础，让他们能够开始使用和学习容器——无论是 LXC、Docker 还是下一个大型容器技术。\n就个人而言，我通过故事学得最好，为了应对新事物，我必须在脑海中发展故事；我不仅想了解我们在学习过程中所处的位置，还想了解我们是如何到达这里的。所以我开始拼凑容器技术的历史，我发现要完全理解它，我们需要回溯到比你想象的更远的地方。我们需要回到 1960 年代早期的虚拟化。\n虚拟化的发展\n早在 60 年代，计算机还是一种稀有商品。光是租一个，每月就要花费一千多美元，这让许多企业望而却步。从这个角度来看，1960 年的 1,000 美元与 2018 年的 8,385 美元具有相同的购买力。\n他们说需求是发明之母，计算机的历史也不例外。最早的计算机通常专门用于可能需要几天甚至几周才能运行的特定任务，这就是为什么在 1960 年代和整个 1970 年代，我们看到了虚拟化的发展。这种发展是由同时在许多用户之间共享计算机资源的需要推动的。\n随着集中式计算机的出现，我们开始看到我们现在所说的虚拟化的初步迹象。\n在整个 1960 年代，多个计算机终端连接到一个大型机，这使得计算可以在一个中心位置完成。集中式计算机使从一个位置控制所有处理成为可能，因此如果一个终端出现故障，用户只需转到另一个终端，在那里登录，仍然可以访问他们的所有文件。然而，这确实有一些缺点。例如，如果用户要让中央计算机崩溃，系统就会因所有人而崩溃。像这样的问题表明，计算机不仅需要能够分离出个人，还需要能够分离出系统进程。\n1979 年，随着 chroot（更改根）命令的开发，我们朝着创建共享但隔离的环境又迈出了一步。 chroot 命令可以更改正在运行的进程及其所有子进程的明显根目录。这使得将系统进程隔离到它们自己的隔离文件系统中成为可能，这样就可以在不影响全局系统环境的情况下进行测试。 1982 年 3 月，Bill Joy 在 Unix 的第 7 版中添加了 chroot 命令。\n为了理解容器，我们可以稍微向前跳到 1990 年代，当时计算机安全和网络研究人员 Bill Cheswick 正在努力了解如果允许访问他的系统，破解者将如何利用他们的时间。对于那些不熟悉“破解者”一词的人，它用于指代出于恶意原因闯入计算机系统的人。现在你可能会想，“等等……那不是黑客吗？”但在安全领域，黑客一词通常用于定义识别安全漏洞以便修复而不是利用它们的人。虽然这种差异可能需要它自己的博客文章，但现在，我将使用饼干这个词，因为这是 Cheswick 在他的论文“与 Berferd 的一个晚上，其中一个饼干被引诱、忍受和研究”中使用的术语。在这项研究中，Cheswick 建立了一个环境，使他能够分析破解者的击键，以便追踪破解者并学习他们的技术。他的解决方案是使用 chrooted 环境并对其进行修改。他的研究成果就是我们现在所知的 Linux jail 命令。\n2000 年 3 月 4 日，FreeBSD 将 jail 命令引入其操作系统。虽然它类似于 chroot 命令，但它还包括用于隔离文件系统、用户、网络等的附加进程沙盒功能。FreeBSD jail 使我们能够分配 IP 地址、配置自定义软件安装以及对每个 jail 进行修改。这并非没有自己的问题，因为监狱内的应用程序的功能有限。\n2004 年，我们看到了 Solaris 容器的发布，它通过使用 Solaris Zones 创建了完整的应用程序环境。使用区域，您可以为应用程序提供完整的用户、进程和文件系统空间，以及对系统硬件的访问权限。但是，该应用程序只能看到它自己区域内的内容。2006 年，Google 的工程师宣布他们推出了用于隔离和限制进程资源使用的进程容器。 2007 年，这些流程容器被重命名为控制组 (cgroups)，以避免与容器一词混淆。\n2008 年 cgroups 并入 Linux 内核 2.6.24\n在规模上。但直到我们现在称之为 Docker 的容器变体，才真正开始向容器的转变。\nDocker（技术和公司）一开始是一个名为 dotCloud 的公共 PaaS 产品。 PaaS 解决方案受益于容器技术，它带来了新的功能，例如实时迁移和不间断更新。 2013年，dotCloud开源了其底层容器技术，并称之为Docker Project。对 Docker 项目的日益支持催生了一个庞大的容器采用者社区。不久之后，dotCloud 成为 Docker, Inc.，它除了为 Docker 容器技术做出贡献外，还开始构建自己的管理平台。\nDocker 的流行催生了多个管理平台，包括 Marathon、Kubernetes、Docker Swarm，以及更广泛地说，Mesosphere 在 Mesos 之上构建的 DC/OS 环境，不仅可以管理容器，还可以管理大量其他遗留应用程序例如，写入的数据服务。爪哇。尽管每个平台在如何最好地提供编排和管理方面都有自己的看法，但它们都有一个共同点——使容器在企业中更加主流的驱动力。\n但是，要进一步将容器应用到企业中，需要的不仅仅是编排和管理工具。它也需要目的。换句话说，除非他们了解技术可以解决的问题，否则任何人都不应该关注容器化。\n容器的未来 容器通过仅在主机操作系统和应用程序（或服务）之间创建一个抽象层来避开大部分包袱。与在虚拟机上部署容器相比，这种方法允许每台物理机运行更多的容器。\n从架构的角度来看，虚拟化用于抽象硬件，这意味着每个虚拟机都必须具有操作系统及其所有依赖项——只有这样才能安装应用程序或服务并使其可用于云实例。\n容器也比虚拟机小得多。由于这些问题，预计更多的容器将部署在裸机服务器上。展望未来，已经表明容器将部署在更轻量级的管理程序上以提供更大的隔离，而不必产生与部署在现有管理程序上的虚拟机相关的所有开销。\n然而，今天，大多数容器都部署在本地或公共云中运行的虚拟机之上。或在 PaaS 环境的上下文中。主要原因是大多数组织要么对容器提供的与使用虚拟机管理程序的虚拟机相比缺乏隔离感到不舒服，要么他们还没有适当的技能或工具来管理裸机服务器上的容器.\n去年，在新兴的“云原生”应用程序以及 IT 组织希望将现有遗留应用程序“容器化”以更轻松地将其提升并转移到云中的情况下，容器的使用急剧加速。随着云原生开发方法的采用成熟，现在确实是容器何时（而不是是否）成为应用程序交付的事实标准的一个案例。\nIT 组织接下来面临的挑战将是弄清楚如何最好地管理容器化应用程序以及在旧平台上运行的所有现有应用程序，这些应用程序不太可能很快被淘汰。\n"},{"id":15,"href":"/kubernetes/docs/%E7%AC%AC%E5%9B%9B%E7%AB%A0-kubernetes-kubelet%E5%BC%80%E5%8F%91/4.1-%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%8E%A5%E5%8F%A3cri/kubernetes%E5%AE%B9%E5%99%A8%E5%8C%96%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8F%91%E5%B1%95/","title":"4.1.2 kubernetes容器化运行时发展","section":"4.1 容器运行时接口CRI","content":"Introduction #  "},{"id":16,"href":"/kubernetes/docs/%E7%AC%AC%E5%9B%9B%E7%AB%A0-kubernetes-kubelet%E5%BC%80%E5%8F%91/4.1-%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%8E%A5%E5%8F%A3cri/%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3/","title":"4.1.3 容器运行时接口详解","section":"4.1 容器运行时接口CRI","content":"Introduction #  "},{"id":17,"href":"/kubernetes/docs/%E7%AC%AC%E5%9B%9B%E7%AB%A0-kubernetes-kubelet%E5%BC%80%E5%8F%91/4.1-%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%8E%A5%E5%8F%A3cri/%E5%BC%80%E6%BA%90%E7%A4%BE%E5%8C%BA%E7%8E%B0%E7%8A%B6/","title":"4.1.4 开源社区现状","section":"4.1 容器运行时接口CRI","content":"Introduction #  "},{"id":18,"href":"/kubernetes/docs/%E7%AC%AC%E5%9B%9B%E7%AB%A0-kubernetes-kubelet%E5%BC%80%E5%8F%91/4.1-%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%8E%A5%E5%8F%A3cri/cri-o%E8%AF%A6%E8%A7%A3/","title":"4.1.5 CRI-O详解","section":"4.1 容器运行时接口CRI","content":"Introduction #  "},{"id":19,"href":"/kubernetes/docs/%E7%AC%AC%E5%9B%9B%E7%AB%A0-kubernetes-kubelet%E5%BC%80%E5%8F%91/4.1-%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%8E%A5%E5%8F%A3cri/cri%E6%8E%A5%E5%8F%A3demo%E5%BC%80%E5%8F%91/","title":"4.1.6 CRI接口Demo开发","section":"4.1 容器运行时接口CRI","content":"Introduction #  "},{"id":20,"href":"/kubernetes/docs/%E7%AC%AC%E4%B8%80%E7%AB%A0-kubernetes-%E7%AE%80%E4%BB%8B/1.2-kubernetes%E6%9E%B6%E6%9E%84/kubernetes%E6%9E%B6%E6%9E%84%E5%9B%BE/","title":"Kubernetes架构图","section":"1.2 kubernetes架构","content":"test #  "},{"id":21,"href":"/kubernetes/docs/%E7%AC%AC%E4%B8%80%E7%AB%A0-kubernetes-%E7%AE%80%E4%BB%8B/1.2-kubernetes%E6%9E%B6%E6%9E%84/kubernetes%E7%BB%84%E4%BB%B6/","title":"Kubernetes组件","section":"1.2 kubernetes架构","content":"test #  "}]